name: Deploy to AKS

on:
  push:
    branches: [ main ]
  workflow_dispatch:  # Allow manual triggers
    inputs:
      auto_stop_cluster:
        description: 'Stop cluster after deployment to save costs?'
        required: true
        default: 'true'
        type: choice
        options:
          - 'true'
          - 'false'
      deployment_environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
          - 'production'
          - 'staging'
          - 'development'

env:
  REGISTRY_NAME: thesistrackregistry
  CLUSTER_NAME: aks-thesistrack
  CLUSTER_RESOURCE_GROUP: rg-thesistrack
  NAMESPACE: default
  AUTO_STOP_CLUSTER: ${{ github.event.inputs.auto_stop_cluster || vars.AUTO_STOP_CLUSTER || 'true' }}
  DEPLOYMENT_ENV: ${{ github.event.inputs.deployment_environment || 'production' }}

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
    
    - name: Start AKS cluster (if stopped)
      run: |
        echo "Checking AKS cluster status..."
        echo "Deployment Environment: ${{ env.DEPLOYMENT_ENV }}"
        echo "Auto Stop Cluster: ${{ env.AUTO_STOP_CLUSTER }}"
        
        CLUSTER_STATUS=$(az aks show --name ${{ env.CLUSTER_NAME }} --resource-group ${{ env.CLUSTER_RESOURCE_GROUP }} --query "powerState.code" -o tsv)
        echo "Current cluster status: $CLUSTER_STATUS"
        
        if [ "$CLUSTER_STATUS" = "Stopped" ]; then
          echo "Starting AKS cluster..."
          az aks start --name ${{ env.CLUSTER_NAME }} --resource-group ${{ env.CLUSTER_RESOURCE_GROUP }}
          echo "Waiting for cluster to be ready..."
          sleep 120  # Wait 2 minutes for cluster to fully start
        else
          echo "Cluster is already running"
        fi
    
    - name: Build and push backend image
      run: |
        echo "Building backend image..."
        # Login to ACR
        az acr login --name ${{ env.REGISTRY_NAME }}
        
        # Build and push backend image
        docker build --platform linux/amd64 -t ${{ env.REGISTRY_NAME }}.azurecr.io/thesis-backend:${{ github.sha }} ./backend
        docker build --platform linux/amd64 -t ${{ env.REGISTRY_NAME }}.azurecr.io/thesis-backend:latest ./backend
        docker push ${{ env.REGISTRY_NAME }}.azurecr.io/thesis-backend:${{ github.sha }}
        docker push ${{ env.REGISTRY_NAME }}.azurecr.io/thesis-backend:latest
    
    - name: Build and push frontend image  
      run: |
        echo "Building frontend image..."
        # Build and push frontend image
        docker build --platform linux/amd64 -t ${{ env.REGISTRY_NAME }}.azurecr.io/thesis-frontend:${{ github.sha }} ./frontend
        docker build --platform linux/amd64 -t ${{ env.REGISTRY_NAME }}.azurecr.io/thesis-frontend:latest ./frontend
        docker push ${{ env.REGISTRY_NAME }}.azurecr.io/thesis-frontend:${{ github.sha }}
        docker push ${{ env.REGISTRY_NAME }}.azurecr.io/thesis-frontend:latest
    
    - name: Set up Helm
      uses: azure/setup-helm@v3
      with:
        version: '3.12.0'
    
    - name: Get AKS credentials
      run: |
        az aks get-credentials --resource-group ${{ env.CLUSTER_RESOURCE_GROUP }} --name ${{ env.CLUSTER_NAME }} --overwrite-existing
    
    - name: Install required infrastructure
      run: |
        echo "Installing cert-manager..."
        kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.13.3/cert-manager.yaml
        
        echo "Installing NGINX Ingress Controller..."
        kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.8.2/deploy/static/provider/cloud/deploy.yaml
        
        echo "Waiting for cert-manager to be ready..."
        kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=cert-manager -n cert-manager --timeout=300s || true
        
        echo "Waiting for NGINX Ingress Controller to be ready..."
        kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=ingress-nginx -n ingress-nginx --timeout=300s || true
    
    - name: Clean up existing resources
      run: |
        echo "Cleaning up any existing resources that might conflict with Helm..."
        
        # Delete any existing ClusterIssuer
        kubectl delete clusterissuer letsencrypt-prod --ignore-not-found=true || true
        
        # Delete any existing application resources
        kubectl delete secret thesistrack-secrets --ignore-not-found=true || true
        kubectl delete configmap thesistrack-config --ignore-not-found=true || true
        kubectl delete service backend frontend postgres --ignore-not-found=true || true
        kubectl delete deployment backend frontend postgres --ignore-not-found=true || true
        kubectl delete ingress thesistrack-ingress --ignore-not-found=true || true
        
        # Wait a moment for cleanup to complete
        sleep 10
        
        echo "Cleanup completed"
    
    - name: Deploy to AKS
      run: |
        echo "Deploying to AKS with Helm..."
        helm upgrade --install thesistrack ./k8s/thesistrack \
          --set backend.image.tag=${{ github.sha }} \
          --set frontend.image.tag=${{ github.sha }} \
          --wait --timeout=600s
        
        echo "Deployment completed successfully!"
    
    - name: Verify deployment
      run: |
        echo "Verifying deployment..."
        kubectl get pods -o wide
        kubectl get services
        
        # Wait for pods to be ready
        kubectl wait --for=condition=ready pod -l app=backend --timeout=300s
        kubectl wait --for=condition=ready pod -l app=frontend --timeout=300s
        
        # Get external IP
        EXTERNAL_IP=$(kubectl get service frontend -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
        if [ -n "$EXTERNAL_IP" ]; then
          echo "‚úÖ Application deployed successfully!"
          echo "üåê Frontend URL: http://$EXTERNAL_IP:5173"
          echo "üîí HTTPS URL: https://thesistrack.dev"
        else
          echo "‚ö†Ô∏è  External IP not yet assigned, check later with: kubectl get service frontend"
        fi
    
    - name: Deployment Summary
      run: |
        echo "üéâ Deployment Summary"
        echo "=================="
        echo "Environment: ${{ env.DEPLOYMENT_ENV }}"
        echo "Auto Stop Cluster: ${{ env.AUTO_STOP_CLUSTER }}"
        echo "Commit: ${{ github.sha }}"
        echo "Branch: ${{ github.ref_name }}"
        
        if [ "${{ env.AUTO_STOP_CLUSTER }}" = "true" ]; then
          echo "üí∞ Cost Optimization: Cluster will be stopped to save costs"
          echo "üöÄ To access your app: az aks start --name ${{ env.CLUSTER_NAME }} --resource-group ${{ env.CLUSTER_RESOURCE_GROUP }}"
        else
          echo "üîÑ Cluster will remain running for development/testing"
          echo "‚ö†Ô∏è  Remember to stop manually: az aks stop --name ${{ env.CLUSTER_NAME }} --resource-group ${{ env.CLUSTER_RESOURCE_GROUP }}"
        fi
    
    - name: Stop AKS cluster (cost optimization)
      if: always() && env.AUTO_STOP_CLUSTER == 'true'  # Only stop if AUTO_STOP_CLUSTER is true
      run: |
        echo "Stopping AKS cluster to save costs..."
        az aks stop --name ${{ env.CLUSTER_NAME }} --resource-group ${{ env.CLUSTER_RESOURCE_GROUP }} --no-wait
        echo "‚úÖ Cluster stop initiated (runs in background)"
        echo "üí° To access your app, restart cluster with: az aks start --name ${{ env.CLUSTER_NAME }} --resource-group ${{ env.CLUSTER_RESOURCE_GROUP }}"
    
    - name: Keep cluster running
      if: always() && env."GET /api/v1/theses/ba5462ac-b12a-4f6c-9e10-80bfda27352a == 'false'
      run: |
        echo "üîÑ Keeping AKS cluster running as requested"
        echo "üí° Cluster will continue running (may incur costs)"
        echo "üí° To stop manually: az aks stop --name ${{ env.CLUSTER_NAME }} --resource-group ${{ env.CLUSTER_RESOURCE_GROUP }}" 